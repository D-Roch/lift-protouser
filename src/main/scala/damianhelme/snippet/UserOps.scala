package damianhelme.snippet

import scala.xml.{NodeSeq, Text}
import net.liftweb.util.Helpers._
import net.liftweb._
import net.liftweb.http._
import net.liftweb.http.js.jquery.JqJsCmds._
import util._
import common._
import java.util.Date
import damianhelme.model.{User}
import Helpers._
import java.io.File
import net.liftweb.http.js.JsCmds.{Alert,SetHtml}
import net.liftweb.http.js.JsCmd
import net.liftweb.common.Logger
import net.liftweb.util.Mailer.{From,Subject,To,BCC,MailBodyType,xmlToMailBodyType}
import net.liftweb.http.Templates
import scala.xml.Elem

    import net.liftweb.util.Helpers._
class UserOps extends Logger {
  
  // a RequestVar for holding the user that's the subject of either the sigup or 
  // edit form - used to pass the user instance between the form GET and PUT requests
  object userInForm extends RequestVar[User]({User.create})
  
  // share field processing between signup and edit user
  def sharedFormFields = {
    val user = userInForm.is
    "#hidden" #> SHtml.hidden( () => {userInForm(user)}) &
    "#firstname" #> userInForm.is.firstName.toForm &
    "#lastname" #> userInForm.is.lastName.toForm &
    "#email" #> userInForm.is.email.toForm 
  }

  /**************************************************************************
   * Sign Up Stuff
   */
  
  // called from user/signup.html
  def signup = {
    def processSignup() = {
      debug("inprocessSignup: " + userInForm)
      userInForm.is.validate match {
        case Nil =>
          userInForm.is.validated(User.skipEmailValidation).uniqueId.reset.save
          if (!User.skipEmailValidation) {
            sendValidationEmail(userInForm.is)
            S.notice(S.??("sign.up.message"))
            S.notice("User Saved")
          } else {
            User.logUserIn(userInForm, () => {
              S.notice(S.??("welcome"))
              S.redirectTo(User.homePage)
            })
          }
        case errors =>
          S.error(errors)
      }
    }
    
    // the first time signup is called, userInFrom will be initialised with a
    // new User instance the first time userInForm.is is called
    sharedFormFields &
    // as we're signing up the user we use the password.toForm method. This generates 
    // two password fields, one to enter the password the other to confirm
    "#password" #> userInForm.is.password.toForm &
    "#submit" #> SHtml.submit("Sign Up", processSignup)
  }

  def generateValidationEmailBodies(user: User,
                                    resetLink: String): List[MailBodyType] = {
    List(xmlToMailBodyType(signupMailBody(user, resetLink)))
  }

  def signupMailBody(user: User, validationLink: String): Elem = {
    val templatePath = List("user", "signupmailbody")
    val template = Templates.findRawTemplate(templatePath, S.locale)

    template.map(t => {
      // note - needed to put 'dear' in here rather than in the template file as
      // the test was failing, the space after the 'dear' was getting lost somehow
      val out = ("#dear" #> ("Dear " + user.shortName) &
        "#validationLink [href]" #> validationLink)(t)
      out.head.asInstanceOf[Elem]
    }).openOr {
      val msg = "template: " + templatePath + " not found"
      error(msg)
      throw new Exception(msg)
    }
  }
  /**
   * Send validation email to the user.  The XHTML version of the mail
   * body is generated by calling signupMailBody.  You can customize the
   * mail sent to users by override generateValidationEmailBodies to
   * send non-HTML mail or alternative mail bodies.
   */
  def sendValidationEmail(user: User) {
    val resetLink = S.hostAndPath + "/" + User.validateUserPath.mkString("/") +
      "/" + Helpers.urlEncode(user.uniqueId.toString)

    val email: String = user.email.toString

    debug("sending validation email to: " + email )
    /**
     * Generate the mail bodies to send with the valdiation link.
     * By default, just an HTML mail body is generated by calling signupMailBody
     * but you can send additional or alternative mail by override this method.
     */
    Mailer.sendMail(From(User.emailFrom),Subject(User.signupMailSubject),
                    (To(email) :: 
                     generateValidationEmailBodies(user, resetLink) :::
                     (User.bccEmail.toList.map(BCC(_)))) :_* )
  }

  /**************************************************************************
   * Edit User Stuff
   */
  def edit = {
    if (! userInForm.set_? )
      userInForm(User.currentUser.open_!)
    //val user: User = User.currentUser.open_! // we know we're logged in

    // def processEditSave(user: User) = {
    def processEditSave = {
      userInForm.is.validate match {
      case Nil =>
        userInForm.is.save
        S.notice(S.??("profile.updated"))
        S.redirectTo(User.homePage)
      case xs => S.error(xs)
      }
    }

    sharedFormFields &
    "#submit" #> SHtml.submit("Save", () => processEditSave)

  }
   /**************************************************************************
   * Change Password stuff
   * - called when the user is logged in, and knows his password but wants to 
   * change it.
   */
  def changePassword = {
    val user = User.currentUser.open_! // we can do this because the logged in test has happened
    object oldPassword extends RequestVar[String]("")
    object newPassword1 extends RequestVar[String]("")
    object newPassword2 extends RequestVar[String]("")

    def testAndSet() {
      if (!user.password.match_?(oldPassword)) S.error(S.??("wrong.old.password"))
      else {
        user.password.setList(newPassword1.is :: newPassword2.is :: Nil)
        user.validate match {
          case Nil => user.save; S.notice(S.??("password.changed")); S.redirectTo(User.homePage)
          case xs => S.error(xs)
        }
      }
    }

    "#oldPassword" #> SHtml.password(oldPassword.is, oldPassword(_)) &
    "#newPassword1" #> SHtml.password(newPassword1.is, newPassword1(_)) &
    "#newPassword2" #> SHtml.password(newPassword2.is, newPassword2(_)) &
    "#submit" #> SHtml.submit("Submit", testAndSet _)
 
    // bind("user", changePasswordXhtml,
         // "old_pwd" -> SHtml.password("", s => oldPassword = s),
         // "new_pwd" -> SHtml.password_*("", LFuncHolder(s => newPassword = s)),
         // "submit" -> changePasswordSubmitButton(S.??("change"), testAndSet _))

  }
  /**************************************************************************
   * Login stuff
   */
  protected def capturePreLoginState(): () => Unit = () => {}
  
  def login = {

    import net.liftweb.http.js.JsCmds.FocusOnLoad
    object usernameRV extends RequestVar[String]("")
    object passwordRV extends RequestVar[String]("")

    val username = usernameRV
    val password = passwordRV
    
    def doLogin = {
      debug("doing login: " + username.is + ", " + password.is)
      User.findUserByUserName(usernameRV.is) match {
        case Full(user) if user.validated.is &&
          user.password.match_?(passwordRV.is) => {
            val preLoginState = capturePreLoginState()
            val redir = User.loginRedirect.is match {
              case Full(url) =>
                User.loginRedirect(Empty)
              url
              case _ =>
                User.homePage
            }

            User.logUserIn(user, () => {
              S.notice(S.??("logged.in"))
              preLoginState()
              S.redirectTo(redir)
            })
          }

        case Full(user) if !user.validated.is =>
          S.error(S.??("account.validation.error"))

        case _ => S.error(S.??("invalid.credentials"))
      }
    }

    "#hidden" #> SHtml.hidden(() => { usernameRV(username); passwordRV(password) }) &
    "#email" #> FocusOnLoad(SHtml.text(username.is, username(_))) &
    "#password" #> SHtml.password(password.is, password(_)) &
    "#submit" #> SHtml.submit("Login", () => doLogin)
  }
  
  /********************************************************************
   * Lost Password Stuff 
   */
  
  // called from /usr/lostpassword.html
  def lostPassword = {
    /**
     * Send password reset email to the user.  The XHTML version of the mail
     * body is generated by calling passwordResetMailBody.  You can customize the
     * mail sent to users by overriding generateResetEmailBodies to
     * send non-HTML mail or alternative mail bodies.
     */
    def sendPasswordReset(email: String) {
      User.findUserByUserName(email) match {
        case Full(user) if user.validated =>
          user.uniqueId.reset.save
          val resetLink = S.hostAndPath+
          User.resetPasswordPath.mkString("/", "/", "/")+urlEncode(user.uniqueId.is)
          // "/" + User.resetPasswordPath.mkString("/") + "?id="+urlEncode(user.uniqueId.is)
  
          val email: String = user.email.is
  
          Mailer.sendMail(From(User.emailFrom),Subject(User.passwordResetEmailSubject),
                          (To(user.email.is) ::
                           generateResetEmailBodies(user, resetLink) :::
                           (User.bccEmail.toList.map(BCC(_)))) :_*)
  
          S.notice(S.??("password.reset.email.sent"))
          S.redirectTo(User.homePage)
  
        case Full(user) =>
          sendValidationEmail(user)
          S.notice(S.??("account.validation.resent"))
          S.redirectTo(User.homePage)
  
        case _ => S.error(User.userNameNotFoundString)
      }
    }

    "#email"    #> SHtml.text("", sendPasswordReset _) 
    // note we don't need to bind anything to the submit button as everything
    // happens in sendPasswordReset
    // & "#lostpass" #> SHtml.submit("Submit",() => ())
  }
  
  def passwordResetMailBody(user: User, resetLink: String) : Elem = {
    val templatePath = List("user", "passwordresetmailbody")
    val template = Templates.findRawTemplate(templatePath, S.locale)

    template.map(t => {
      // note - needed to put 'dear' in here rather than in the template file as
      // the test was failing, the space after the 'dear' was getting lost somehow
      val out = ("#dear" #> ("Dear " + user.shortName) &
        "#resetPasswordLink" #> <a href={resetLink}>{resetLink}</a>)(t)
      out.head.asInstanceOf[Elem]
    }).openOr {
      val msg = "template: " + templatePath + " not found"
      error(msg)
      throw new Exception(msg)
    }
  }

  def generateResetEmailBodies(user: User, resetLink: String): List[MailBodyType] = 
    List(xmlToMailBodyType(passwordResetMailBody(user, resetLink)))
  

  /********************************************************************
   * Password Reset Stuff - as password reset link gets sent
   * to the user after they have submitted the 'lost password' form
   */
  def resetPassword = {
    
    // the password reset request comes in with a unique id on the end
    // e.g. /user/resetpassword/K2UVO2NH51P5HT1WOA5PMCDRSM2PIS2R 
    val id = (for (r <- S.request) yield r.path.wholePath.last) openOr ""
    
    // the user is asked to enter two passwords and we check they match
    var password1 = ""
    var password2 = ""
      
    User.findUserByUniqueId(id) match {
      case Full(user) =>
        def finishSet() {
          user.password.setList(password1 :: password2 :: Nil)
          user.validate match {
            case Nil => S.notice(S.??("password.changed"))
              user.uniqueId.reset().save
              User.logUserIn(user, () => S.redirectTo(User.homePage))
            case xs => S.error(xs)
          }
        }
        "#password1" #> SHtml.password("", password1 = _) &
        "#password2" #> SHtml.password("", password2 = _) &
        "#submit" #> SHtml.submit("Submit", finishSet _)
        
      case _ => S.error(S.??("password.link.invalid")); S.redirectTo(User.homePage)
    }
  }

}

